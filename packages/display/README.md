# @spheres/display

Create a browser-based user interface as a function of application state,
with fine-grained reactive updates.


## Introduction

`@spheres/display` provides a Typescript API for building views with HTML
or SVG elements generated by functions of application state, with
autocompletion of the correct attributes associated with an element.
Application logic is defined using state primitives provided by
`@spheres/store`. Browser event handlers produce messages
that will be dispatched automatically to the application Store. These
messages in turn trigger state updates that are automatically propagated
to update the view as necessary. And `@spheres/display` will only
update those parts of the view that depend on state that has changed.

The views created with `@spheres/display` are composed of synchronous
functions. No async code is used in the construction of a view.
Furthermore, all state is handled in terms of `@spheres/store` State Tokens.
There are no components.

Views depend on state in two ways.

First, the value of any element attribute can be specified in terms of a
function that depends on state. In such a case, the attribute's value -- and
only the attribute's value -- will be updated whenever the referenced
state tokens come to represent a new value. The same is true for text
associated with an element.

Second, segments of a view may be designated as 'zones' that depend on state.
Within a zone, the View itself can depend on state and will be patched
whenever the referenced state tokens come to represent a new value.

In these ways, the areas of the View that depend on state can be specified
precisely and updates will be performed in those areas only. This is what
we mean by saying that `@spheres/display` supports *fine-grained* reactive
updates.


## An Example

Consider a simple counter appliction. The application logic consists of
a single `Container` with a reducer that increments the counter value. The
view shows text with the current counter value. A button is defined with
an event handler that produces a message to update the counter. As the
button is clicked, the text with the counter value is the only part of the
view that will be re-rendered.


```
import { View, htmlView } from "@spheres/display";
import { container, write } from "@spheres/store";

const clickCount = container({
  initialValue: 0,
  reducer: (message: string, current) => {
    if (message === "increment") {
      return current + 1
    } else {
      return current
    }
  }
})

function counter(): View {
  return htmlView().main(el => {
    el.children
      .p(el => {
        el.children.textNode((get) => `Clicks: ${get(clickCount)}`)
      })
      .button(el => {
        el.config.on("click", () => write(clickCount, "increment"))
        el.children.textNode("Count!")
      })
  })
}

const display = createDisplay()
display.mount(document.getElementById("app")!, counter())
```

See more examples [here](https://github.com/brian-watkins/spheres/tree/main/examples).

## API

`@spheres/display` provides a Typescript API to build Views composed
of HTML or SVG elements.

### Building Views

To build a view begin with the `htmlView()` or `svgView()` functions, which
each expose an object with functions named for the HTML or SVG
elements, respectively. Each element function takes a configuration function
that has one argument, `ConfigurableElement`. A ConfigurableElement exposes
two properties `config` and `children` which allow for setting the attributes
of the element and its child elements. Chain attributes to add more. To build
child elements, chain calls to the appropriate element function and follow
the same procedure for each, passing in to the element function a configuration
function. Here's an example:

```
htmlView().main(({ config, children }) => {
  config
    .id("main-element")
    .class("bg-red-500")
  children
    .p(({ config, children }) => {
      children.textNode("Hello!")
    })
    .p(({ config, children }) => {
      children.textNode("Another paragraph!")
    })
})

// Generates ...
//
// <main id="main-element" class="bg-red-500">
//   <p>Hello!</p>
//   <p>Another paragraph!</p>
// </main>
```

### Special Element Functions

When constructing an element (either from `htmlView()`, `svgView()`, or the
`children` property of some ConfigurableElement), besides functions that
create elements of a specific type (like `a`, `p`, `div`, etc), there are
a few special functions to note.

#### element

Use the `element` function to create an element with an arbitrary tag name,
useful for working with custom elements.

```
htmlView()
  .element("my-cool-element", ({ config, children }) => {
    ...
  })
```

#### textNode

To add text call the `textNode` function

```
htmlView()
  .p(({ config, children }) => {
    children.textNode("My paragraph!")
  })
```

A textNode may take a string value or a `Stateful<string>`, which is a function
based on state that produces a string: `(get: GetState) => string`. For example:

```
htmlView()
  .p(({ config, children }) => {
    children.textNode((get) => get(content))
  })
```

Here, the `p` element's text content -- and only the text content -- will
update whenever the `content` state token comes to represent a new value.

#### zone

Use the `zone` function to compose View-generating functions into more
complicated structures. For rendering purposes, a Zone is an autonomous
area that is treated like an opaque block. Any patching based on state
updates occurs inside the Zone; from the perspective of the parent element,
a zone is just a block of HTML that can be added, deleted, or rearranged
with respect to other content. If the parent element needs to reorder
zone elements, a key must be provided when defining the zones -- otherwise
the renderer will not be able to distinguish these elements.

A `zone` function can either take a function that produces a view:
```
() => View
```
or a function that produces a view based on state:
```
(get: GetState) => View
```
where `GetState` is a function of the type `(state: State<T, M>) => T`
that provides a way to get values from `@spheres/store` State Tokens.

When a zone is created with a function that produces a view based on
state, that function will re-run to produce an updated View each time
the referenced State Tokens come to represent a new value, and the
DOM will be patched accordingly.

By using the `zone` function, `@spheres/display` circumscribes the area
of the DOM needed for patching based on state updates, so that only
those parts of the view that should be updated will be updated.

Here's an example that creates a select element with options
determined by state

```
htmlView().zone((get) => {
  return htmlView().select(({ config, children }) => {
      for (const record of get(myData)) {
        children
          .option(({ config, children }) => {
            config.value(`${record.id}`)
            children.textNode(`${record.lastName}, ${record.firstName}`)
          })
      }
    })
})
```


### Stateful Attributes

All attribute functions may take either a value `T` (usually a string)
or a `Stateful<T>` value:

```
type Stateful<T> = (get: GetState) => T | undefined
```

which is just a function based on state that produces a value. For example,
to change the class of an element based on some state:

```
htmlView().div({ config } => {
  config.class((get) => get(isError) ? "error-class" : "ok-class")
})
```

Once this View is rendered, the class attribute -- and only the class
attribute -- will be updated whenever the `isError` state token comes to
represent a new value.


### Special Attribute Functions

When configuring an element, the `config` property contains functions
for defining all the possible attributes that belong to that element. In
addition, there are a few more functions available through the `config`
property to note.

#### attribute

Create an arbitrary attribute by providing a name and string or `Stateful<string>`
value to the `attribute` function.

```
htmlView().div({ config } => {
  config.attribute("my-attr", "my-value")
})

// Generates
//
// <div my-attr="my-value">
```

#### dataAttribute

Provide a data attribute with the `dataAttribute` function. The value may be
a `Stateful<string>`.

```
htmlView().div({ config } => {
  config.dataAttribute("sports", "bowling")
})

// Generates
//
// <div data-sports="bowling"></div>
```

#### innerHTML

Provide an HTML string or `Stateful<string>` to be set as the content of this
element. Any children set on the element will be ignored.

#### aria

Provide an aria attribute and value or `Stateful<string>` via the `aria` function.

```
htmlView().div(({ config }) => {
  config.aria("hidden", "true")
})

// Generates
//
// <div aria-hidden="true"></div>
```

#### on

To add an event handler to an element, use the `on` function and provide
the appropriate event type. The event handler function must return a `StoreMessage`
that will be automatically dispatched to the Store associated with this Display.

```
htmlView().button(({ config }) => {
  config.on("click", () => write(myContainer, "some text"))
})
```