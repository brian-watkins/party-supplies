# Rendering

For LDS, it turns out that the overview page doesn't have any interactivity.
BUT it does load data for a particular user. So, the simplest thing to
do from the client perspective would be to just return HTML with the
appropriate data filled in. Right now what we do is return the data in a
script tag on the page, set it on a variable on the window, and then run
the display code to render the HTML. What we are considering is whether we
could do this rendering of HTML on the server and /simply/ return HTML to the
client.

For this particular use case, it seems extremely straightforward to
build the virtual dom and render it as HTML. We already expose a function that
takes state and renders a virtual dom tree. Then we would just have to take
that and render HTML in our serverless function. There's even already a
package that will convert snabbdom vnodes to HTML.

The trick is how to deal with more complicated cases, like if there is an
event handler attached to a vnode. Currently the `snabbdom-to-html` package
doesn't seem to support event handlers, only classes, properties, attributes,
and styles. This would suffice for us but not in general.

Note that for esdisplay, event handlers should just return messages that get
bubbled up as a custom event. For us to support this while rendering HTML we'd
need to somehow:

1. acknowledge that an event handler needs to be added to a node and have a
way to identify that node
2. add a script tag that attaches the event handler
3. load the display runtime so that custom display events are captures and
dispatched to the loop.

But for us, generally an event handler is going to write to some container or
trigger a rule for some container. That's all we can do right now in fact.
But that means that the rendered HTML page would need to load the referenced
container somehow. And that's where this starts to get more difficult I think.
How do we send all that javascript to the client? Seems like we might need some
kind of bundling step where we determine what needs to get imported and add some
script tag that loads the bundled JS.

OR, could we utilize es modules here somehow? So we're doing more what vite is
doing when it's in dev server mode?

Note too that react server components apparently send virtual dom information
to the client (and not html, except maybe on initial load). So that's another thought
that's similar to what we're doing now. Create the vnode and then send a representation
of that to the client which then renders it. That doesn't help with our state
problem though ... since any event handler function will have a reference to a
container object that is just a JS object ...

We could maybe just start out with rendered static html and no event handlers,
and see where that goes ...

The thing is though that you could have 'state' on the server side with a provider
that fetches things from a database or whatever. But is that what we would want?
Right now the static overview page is generated by a serverless function that calls
`getInitialState` -- this gets the initial state and a template; then the renderer
replaces a string in the template with the serialized state. and then the file is
returned to the client. In other words, we're not using the loop at all on the
server side, and maybe shouldn't need to? The loop is there to support reactivity
basically, and on the server side we don't care about reactivity, since it's just a
one time thing.

But the implication I guess is that any reference to state signifies a client-side
concern. Is that helpful? What we need is a way to generate an entry point basically.
And then esbuild or whatever would put together what we need to provide to the
client.

It's kind of nice to think about this in terms of 'serverless-ness' -- in other
words, I don't care how this is rendered, I just want to represent what I want
using esdisplay and then the runtime figures out what to do with it. In our case,
we expose a function that generates a View and then the runtime (the serverless
function in this case) knows to convert that to HTML. It would be cool if somehow
we could leverage that same pattern when we are dealing with the case where
the client needs to have interactivity and state etc, BUT some of the data can
be fetched on the server-side and (somehow) passed to the client instead of waiting
for the client to load and then request it.

But what's the difference between what we're doing now (passing data to the client
in the generated HTML) and something more, like where part of the view is rendered
as HTML? We'd probably /still/ need to pass the data so that it could be available to
any other Views that needed it? Maybe it would be slightly faster to render some HTML
instead of waiting for the virtual dom to work its magic? But then you get into
the question of what to do with parts of the page that depend on state and so
must be rendered dynamically -- ie the whole motivation for React suspense I guess.
The key here is that:

1. I don't want to write HTML and so I don't want to use templates of any kind
2. I may want parts of the View code to show up on the client as HTML and parts
to be filled in by the virtual dom patching mechanism.

Maybe this is just a bad thing to wish for or a perceived performance problem that's
not really worth fixing (kind of like the extra update problem in react, although
we did happen to fix that ha).

What we might be able to do is have a renderer that does as much static html as it can
but as soon as it hits a function that uses state or maybe even has an event handler
it finds a way to load that part dynamically. This is kind of what I imagine the
'islands' approach is like? https://www.patterns.dev/posts/islands-architecture

The first step, though, is just to render static html. And for that I think we
need to have a function that takes a `View` and outputs a string of HTML. That
would be sufficient for us to render the overview page I think.

Currently `Display` is a class with a `mount` function for a DOM element, and it
takes the loop and a `View`. It needs the loop in order to dispatch functions
automatically -- that's the only reason. So we could move that reference outside
and wire it up in a different way.

For the renderer maybe it's just a function (or a class) that takes a `View` and
has a `render` function that returns a string? It could /just/ be a function that
takes a View and returns a string too. The Display needs to be a class because it
holds a reference to the app so it can destroy it if necessary.

The render function might need to return an object rather than simply a string
in case we need to provide more stuff -- like a list of imports to add to the
page or something.

### Full Stack Test

So how do I run a full stack test? I need to somehow do two things:

1. Generate the HTML -- this is the server-side rendering and should account
for the case where we would render HTML on each request because there's
user data that should be included.
2. Load the generated HTML in a browser along with anything else -- we need
an HTML page template that the generated HTML will be included within and that
template should contain any other script tags that load the JS that will
reactivate the stateful views.
3. Make assertions about the DOM in the browser -- so click on some things and
see certain views update just like one would expect.

Maybe for (1) & (2) I can get vite to proxy to a server that I start during
the test? Actually, note that Vite somehow has support for server side rendering.

Looks like we could set up Vite dev server in middleware mode to be able
to handle things. And that would allow us to create a function that does all the
rendering and template generation. Then we add some vite specific stuff
to get things like HMR to work (probably not necessary just for tests, but
may also replace other things like css or other links like to script content).

Note that we already have the click counter app fixture. We could reuse that and
then we just need to render it to a string and serve it up and then activate
it on the client side.

So my test needs to open up a particular html page like `/app/clickCounter.html`
and then this will trigger some code that imports `clickCounter.app.ts` and
renders the default export view function to HTML and then generates an HTML
page that is served up.

This works; we have a failing test.

### Getting it to pass

but now how do I get it to pass?

We need to load some javascript. This JS needs to do something like what
the display does. In short, it needs to *also* load the view but then for each
view-fragment, it needs to replace that view-fragment with a patched vdom tree.

I wonder if I could find the `view-fragment` in the dom and then find the
view-fragment vdom element in the vdom tree. Then assign the element to the
vdom node, and then do the same thing that the create hook does -- or just
call the create hook.

It works!

But in a very hard-coded way ... we need to find out a way to make it more
generalized.

### Making it better

One thing that has to happen right now is the activate script needs to
pull in the entire view at once and then crawl it to find `view-fragment`
elements.

We could try introducing an `island` element that just takes a path to
a file as its only attribute. Behind the scenes this would just work like
other stateful views but then maybe somehow we could just load the JS for
each particular island -- since we really all we need is that particular
vnode which contains the stuff needed to mount it via the create hook.

This seems good because it would conceivably allow for code splitting as
well. And we could control when we load these too ... all async or when
they become visible or whatever.

And note that we don't need to worry about unsubscribing with these top
level 'island' components since they shouldn't ever go away -- their parent
is always static, so long as you use esdisplay for everything. We would have
to somehow force that there can be no nested `island` components though.

I think we could get island components working even when not server-side
rendering too. And indeed, we'd have to do some stuff to get them working
when rendering html strings too, since the island component would introduce
async behavior into the view process. Basically, I think, the function to
generate the initial view tree would become async. But after that it should
be fine. This might also give us more options for when we render normal
stateful views to HTML -- so that we could avoid having the initial value
returned when creating a derived state.

I guess an `island` would have to return a `Promise<View>` which would then
force the whole tree from there on back to the root to also be a `Promise<View>`.

How could we prohibit nested `island` components? One way might be that the
`island` must reference a module with a default export that is not async. Ie:

```
export default function (get: <S>(state: State<S>) => S): View
```

And then it could not contain any async stuff inside there I guess, right?

We were able to do this, but we need to do the dynamic import from the
module that defines the island. It's a little awkward but I don't think there's
a better way since imports are relative to the file doing the importing
anyway.

But now the test is a little flakey since there is some time between when
the view is loaded and when the view is activated. Maybe we need to fire
an event or something when the view is activated?

Next step is to make the island have its own tag and create some kind of
class that can be instantiated and will find all the islands and activate
them. Right now we're pulling in the whole view. But what we want I think
is to scan the dom, find the `view-island` element, which should have a
`src` attribute, dynamically load the referenced module, then create a
stateful view and call its `create` hook to mount it at the `view-island`
element in the dom.

This does work! However, we're needing to do a dynamic import via a
variable which vite does not like. And in general it would be preferable
I guess to have the dynamic import be an explicit string and so printed
as part of the HTML rendered on the server.

But we need some way to get the view island dynamically from the browser.
For that we need the path to the file in the browser. But the way we're
writing the code right now, the path is inside the call to import and so
not accessible. We could use `import.meta.url` *inside* the island
module but I'm not sure exactly what that would do. Unless what we expose
is not just a raw function but some class that would have this on it?

Another problem: If we were to use this like normal in a regular client side
view, right now we would need to wait for the `View` to resolve before
rendering anything. Probably what we want is to provide some kind of fallback
view in the island component to display while it is loading ... but this is
getting us toward something like React Suspense ... And if it's server side
rendered you'd want to just wait and show the loaded view I think

OR ... maybe that's the point? When server-side rendering you could just
print the fallback and then completely load the component on the client side?
But I think it's better to wait and load the full component on the server
side. And anyway the problem is "what do I load exactly on the client" and
you'd still have that problem.

If we load the full view then this goes away ... but then you have to load
the full view function ...

OK BUT if we provide a thunk to the island that actually contains the
import line then we can *convert that to a string* and include it in the
rendered HTML. This will pass on the exact same import declaration to the
frontend (which maybe will work?)

The trick here is that on the server, we need to use node resolution. But on
the client we need to use es6 resolution. These are kind of the same but on
the client it happens to be less strict since we're using vite -- you can
have a `.ts` extension, whereas you can't really on the node side. If I were
using something like Deno it would be different maybe. But you don't always
have control over the server -- our sample project uses azure static web apps
for example.

We could get around this by using an import map in the html we send I think.
Yes ... we learned that the import map needs to be relative to the root,
so even if the import is for `./counter.js` you need to put the absolute
path to it in the import map for it to resolve.

I kind of hope the import map approach is only needed for local development
or testing though. Theoretically, when vite builds, it should notice the
dynamic import in the code, create a new bundle for it and replace the path
name which would then get passed to the server ... and this should all be
`.js` anyway? ... need to test this out.

How should I get the loader into the client though? I can pass it as a data
attribute in the `view-island` element. But then I need to use `eval` on the
client which seems sketchy. I could print it with the rest of the HTML but
then the path will be wrong probably because any relative paths will be resolved
relative to the root.

And what do I need to do to activate things? For each `view-island` I need to
load the module (which contains the derivation function) and then create
an `island` element with that function and then call its `create` hook while
passing in the correct `view-island` element from the dom. So I need to

0. Register an event listener on the dom to pass any custom events to the loop.

Then for each `view-island` ...
1. Fetch the `view-island` element from the DOM. This gets me the element
reference and the attribute with the loader code in it
2. Eval the loader code and load the derivation function
3. Create the `island` View
4. Call the create hook and reference the `view-island` element from the dom.

OR

Each `view-island` comes with its own script that can load the module and
reference the element it's associated with. 
- This would potentially avoid the use of `eval`.
- Each `view-island` would need its own id so that it could be referenced
from the script. Note that module scripts defer by default so it would wait
for the dom to be processed but the `DomContentLoaded` event won't fire
until after the javascript has processed.

For the second option I don't think you actually need anything by way
of a `Display` object ... this could all be automatically included in
`script` tags I think with the rest of the HTML. The only thing is if you
wanted to do something before mounting the elements ... like provide some
data to the state graph ...

Maybe we just need to provide some functions that could be called in
an entrypoint script: `activateIsland` and `activateDisplay` and
`activateIsland` would take an identifier for the island that you provide
when writing the View. But why not just have one function called
`activateIslands` that finds all the islands and activates them at once?

One thing might be that we want to make sure to load the islands in
parallel or even defer loading until the island is visible or something.

This is a decision we should document -- whether to have script tags or
whether to have a function that uses eval to load the modules. And maybe
there's a third option where instead of each island loading itself via a
script tag, we just add a little JS to register the island in some sense --
where it adds to some global object the id and the module loader function.
Then the `activateIslands` function would reference that in order to
find the islands rather than doing a document query ... or it could do the
document query to get the id and then look up the loader function. Or
just add a `load` property to that HTML element in the dom that
`activateIslands` could call ...

We also need to think about still loading any state along with the view and
getting that synced up via a provider. So I think for that reason alone we
really need to have some function that can be called *once the state is ready*
to patch and activate the islands.

OR

maybe we could follow the model of HTMX and use attributes to specify the
loader (which is basically what I'm doing with the data attribute). But again
this would require using eval which is not great. There is "indirect eval"
which might be a little better. And `eval` might be disallowed by certain
content security policies (CSP).

So the best thing would be to print some javascript that runs the loader.
Or sets a property on the element or sets the loader in a global registry
or something like that.

### Bundling

It looks like bundling might mess up the state because defined containers
will be pulled in multiple times. ... I wonder how jotai gets around that?
Note that this was just observed with esbuild. So maybe vite can figure
this out when it builds?

And even on the server side with esbuild ... if you do the dynamic import
and bundle the imported file separately, you will get two different
containers I think ...

But ACTUALLY if you use the `--splitting` flag with esbuild then it works
fine with dynamic imports and everything. The only issue is that now, at least
in our local setup, you have to use an import map ...

Problem now with lds is that I'm serving SOME of the JS via vite and SOME
via the esbuild-bundled files. I need to do one or the other.
- I can also set the index page as an entry point and it seems to use the
same bundles so now I just need to use a webserver to serve those files
instead of trying to go through Vite I think ...
- This works but then we don't get css anymore since Vite was handling that.
But we don't seem to need the input maps anymore!
- But I think it's just an accident that we don't need the input maps ...
the path is what the server side bundle would use and it shows up the same in
the frontend.
- The key here is actually to do a dynamic import of the backstage component
(that produces the renderer function). Why? Because then the dynamic imports
of the island are relative to the other split out js chunk files. Then, if
you were doing just a normal server everything would just work I think. For
LDS, we do a weird thing where the web page is actually redirecting to another
serverless function so you do need an input map to fix this. but otherwise
maybe it would work.
- But it seems that vite messes things up when it builds the server side
component

Now we're trying to build with vite on both the server and the client.
But the server-side build we do seems to externalize all node modules by
default. But this means that we can't use that built file (very easily) on
the client side We could maybe get it to work but it's doing a bunch
of weird stuff.

What makes this a bit difficult is that I'm trying to build the same code
twice, once to import on the server side and once to import from the client,
dynamically. Seems like I should build it once /for the client/ and then
use that bundle on the server-side, since it should still work there.

But the problem is that vite just cares about the index.html page and for the
client-side html template we don't have any reference to the view code with
the dynamic imports, since we assume we will load them based on the island
registry, which is injected after the fact.

But why do we have to dynamically set the island registry? It's not like that's
going to change on every request or anything ... it should just be the same
all the time, right? But I guess it depends on how the view renders ... but
then again, islands are supposed to be not dynamic or not subject to
other state (although in lds it would be if we nest islands underneath
a withState element ...). Nevertheless, each possible island should be associated
with a specific import no matter what (no matter if it happens to be loaded
on the page or not).

So what if you had to manually create the island registry in your html? or
somehow otherwise reference those imports in the html?

Note that there's this 'tropical-islands' thing: https://www.npmjs.com/package/tropical-islands

And they have a hydrate function (similar to our 'activateIslands') that
actually takes as an argument the list of components you want to activate.
Maybe if we did that then we actually *woudln't* have to use the same
code between server and client.

In order to get this to work, I might have to export more than just a
derivation function from the island file. I'd need some kind of identifier
I think so that I could look up the ssr'd island element in the html
content, right? And for this I could do something like export the
`island(derivation)` element rather than just the derivation function. That
would allow me to add more metadata.

But still it seems like to get vite to bundle all the different files, you'd
need to list all possible islands, even if some might not show up. But then
you'd force these to be loaded anyway, if the HTML has a dynamic import there.

Not sure how the tropical-islands stuff actually works, since it doesn't have
a dynamic import for the components you are trying to hydrate? ...

Maybe this is not a problem because you'd always use this with a multi-page
app approach and so each page would just have its own islands. BUT what
about the case in LDS where the engage page has two states -- one where you
are logged in and one where you are not? In the not logged in one then you
would not want to load the islands. Potentially you could, it just wouldn't
matter, but that seems bad. I guess the `activateIslands` function could just
reference the imports in thunks so that they are only called if necessary.
And so the server-side would just print some javascript to list the islands
that actually need to be hydrated. And `activateIslands` contains a list
of loader-thunks for the particular components. Note there could be
the case where there are multiple elements in the rendered html that need
to be activated but which use the very same island component, I guess?

This would be kind of annoying to set up, but I guess that's the cost of
having ssr and only loading certain components on the client side.

ACTUALLY ... it seems like we've jumped ahead a bit. The island architecture
doesn't *necessarily* involve dynamically importing islands. All it says is
that you load *merely* the javascript you need for the areas of interactivity
on the page -- and not for rendering the entire page. So we can distinguish
two cases: (1) Islands where the JS is loaded in one bundle; (2) Islands
where the JS is loaded in a bundle, dynamically, for each island.

We had skipped to (2) but (1) is also a case that we should consider and it
shouldn't be that hard to implement.

The simplest thing, I think, would be to have an `activateIslands` function
that contains a list of island elements. Each of these has a string name
associated with it. When this function runs, we take each element, get the
name, and do a query on the DOM for any `view-island` that has a matching
name attribute. When we find it, we patch it with the virtual element.
And that's it! We just assume that the list of elements in `activateIslands`
matches the elements we need to patch.

And then if we wanted to support dynamic imports, we could do something
similar, where `activateIslands` takes a list of thunks that return an
`IslandElement` or a `Promise<IslandElement>` or even a
`Promise<{ default: IslandElement }>` if we wanted to be able to do the
nicer `() => import("myElement")` approach. Then, in order to activate the
islands you'd need to load all the dynamic imports.

This approach might not support the case where we defer loading JS for an
island until that island scrolls into view. But maybe `activateIslands`
could find the `view-island` elements first and they could have some
meta-data on them? But if the IslandElement is contained in a thunk, you'd
need to run that thunk (and potentially load the element) before
you could know which one is associated with which element. Unless, we did
something like have a hash of thunks with some identifier, rather than
just a list.

We need to introduce an `ViewIsland` type that is something like
`View<Island>` using a phantom type. Not sure what we would call the non-island
view. But then I think we would be able to enforce via the compiler that
an island element cannot contain another island element. But `withState`
could use a derivation function that produces anything -- a `View<any>`.
What would we call a non-island view? `View<Background>`? vs
`View<Foreground>`? `View<Server>` vs `View<Client>` -- that works
for an app that is doing SSR but it might not make sense for a SPA app
where `View<Server>` would then be the default. Could just do `View<void>`
or something, although that seems a little weird. Maybe
`View<General>`? or `View<Basic>` -- A basic view will be rendered
on the server (or the client in SPA mode) but will not be rehydrated. An
island view will be rendered on the server and rehydrated. Or maybe
`View<Simple>` or `View<Normal>` or `View<Standard>`

I could also have a view that just has an event handler -- like when you
trigger some rule on a click. In that case, we might render it on the
server but want the event handler to be wired up on the client. I guess
for that we would need an island? It would definitely need to know what
the JS was. You could easily do that manually in a script block that you
add to the entrypoint or something. But if you wanted to do it automatically,
I guess you'd need to wrap it in an island element.


And for the case in LDS where depending on the state we render an island or
not ... I think we would just make a conditional based on that state (which
we would have anyway because we need to pass it as part of the rendered
HTML so our islands will match when patched) and call `activateIslands` only
if we need to.


It does work! ie giving activateIslands a list of island elements, each of
which has a name that shows up in the dom element. How do we handle multiple
dom elements that match? We need a test for that.

We can also make the view no longer need to return a `Promise<View>`. But on
the activate script, there we could load the elements via dynamic import
if we wanted.

It's still true though that Vite's server-side renderer still loads the view
in such a way that the HTML renderer prints undefined for the count -- instead
of finding its initial value of 0. Not sure why that is.
- There's something here about the fact that Vite is bundling stuff when it
loads the SSR module I think. So there ends up being two loops somehow in the
same node process and maybe somehow it gets confused?
- So I think it's just because we have other things that are also loading
the loop? And the key is that the render function was imported outside the bundle
so then it is using the wrong loop I think




### Updating the html renderer

Maybe there's a thing we could do where we pass a callback through somehow
and as each element renders it calls a `next` function to trigger the
next one in the tree? That's for the actual processing and rendering
which is different from the building on the tree (which is what would
need to be async if we have island components)